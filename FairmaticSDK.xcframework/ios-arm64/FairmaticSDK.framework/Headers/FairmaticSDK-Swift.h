#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.8 (swiftlang-5.8.0.124.2 clang-1403.0.22.11.100)
#ifndef FAIRMATICSDK_SWIFT_H
#define FAIRMATICSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreLocation;
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="FairmaticSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)
/// Confidence measure of the detected accident.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticAccidentConfidence, "AccidentConfidence", open) {
/// Accident was detected with a high confidence. The application might inform
/// emergency services directly after waiting for some time for user feedback.
  FairmaticAccidentConfidenceHigh = 0,
/// Accident was detected, but with a low confidence. The application might ask
/// the user for feedback before notifying any emergency services.
  FairmaticAccidentConfidenceLow = 1,
/// Confidence of an invalidating callback. This might be sent only when the application has opted into multiple accident callbacks
  FairmaticAccidentConfidenceInvalid = 2,
};

@class NSString;
@class FairmaticLocationPoint;
enum FairmaticVehicleType : NSInteger;
enum FairmaticCollisionSeverity : NSInteger;
enum FairmaticDirectionOfImpact : NSInteger;

/// Wrapper for meta-information related to an accident detected by the SDK.
SWIFT_CLASS_NAMED("AccidentInfo")
@interface FairmaticAccidentInfo : NSObject
/// The unique Id of drive during which the accident occured
@property (nonatomic, readonly, copy) NSString * _Nonnull driveId;
/// The location of the accident.
@property (nonatomic, readonly, strong) FairmaticLocationPoint * _Nonnull accidentLocation;
/// The timestamp of the accident in milliseconds since epoch.
@property (nonatomic, readonly) int64_t timestamp;
/// The session that was in progress when the accident occured, if a session
/// was started in the SDK.
/// seealso:
/// <code>Fairmatic.startSession(_:)</code>
@property (nonatomic, readonly, copy) NSString * _Nullable sessionId;
/// The tracking id of the ongoing drive when the accident occured.
/// seealso:
/// <code>Fairmatic.startManualDrive(_:completionHandler:)</code>
@property (nonatomic, readonly, copy) NSString * _Nullable trackingId;
/// The confidence of detected accident.
@property (nonatomic, readonly) enum FairmaticAccidentConfidence confidence;
/// Measures an approximate precision of the detected collision. Ranges between 0 to 100.
/// Note: A confidence number of 0 indicated that it was <em>not</em> an accident.
/// 0 confidence number can be sent as a part of potential accident callback
/// to invalidate the previous callback final accident callback for the same accident.
/// 0 confidence number will never come as a part of potential accident callback.
/// Checkout <code>MockAccidentConfig.invalidateFinalCallback()</code> to test this scenario during development.
@property (nonatomic, readonly) NSInteger confidenceNumber;
/// A unique identifier of this accident.
@property (nonatomic, readonly, copy) NSString * _Nonnull accidentId;
/// Vehicle type detected by SDK at the time of the accident.
/// Default value is <code>VehicleType.car</code>.
@property (nonatomic, readonly) enum FairmaticVehicleType vehicleType;
/// This field specifies the collision severity at the time of potential accident callback and final accident callback.
/// Default value is <code>CollisionSeverity.unknown</code>.
@property (nonatomic, readonly) enum FairmaticCollisionSeverity collisionSeverity;
/// This field specifies the direction of impact at the time of potential accident callback and final accident callback.
/// Default value is <code>DirectionOfImpact.unknown</code>.
@property (nonatomic, readonly) enum FairmaticDirectionOfImpact directionOfImpact;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Initializer for <code>AccidentInfo</code>.
/// \param location The location of the accident
///
/// \param timestamp The timestamp of the accident in milliseconds since epoch
///
/// \param trackingId The tracking id of the ongoing drive when the accident occured
///
/// \param sessionId The session that was in progress when the accident
/// occured, if a session was started in the SDK
///
/// \param confidence Confidence measure of the detected accident
///
/// \param confidenceNumber Confidence number of the detected accident
///
/// \param accidentId A unique identifier of this accident
///
/// \param driveId The unique Id of drive during which the accident occured
///
/// \param vehicleType Vehicle type detected by SDK at the time of the accident
///
/// \param collisionSeverity Collision Severity detected by SDK at the time of the accident
///
/// \param directionOfImpact Direction Of Impact detected by SDK at the time of the accident
///
///
/// returns:
/// <code>AccidentInfo</code> object
- (nonnull instancetype)initWithLocation:(FairmaticLocationPoint * _Nonnull)location timestamp:(int64_t)timestamp trackingId:(NSString * _Nullable)trackingId sessionId:(NSString * _Nullable)sessionId confidence:(enum FairmaticAccidentConfidence)confidence confidenceNumber:(NSInteger)confidenceNumber accidentId:(NSString * _Nonnull)accidentId driveId:(NSString * _Nonnull)driveId vehicleType:(enum FairmaticVehicleType)vehicleType collisionSeverity:(enum FairmaticCollisionSeverity)collisionSeverity directionOfImpact:(enum FairmaticDirectionOfImpact)directionOfImpact OBJC_DESIGNATED_INITIALIZER;
/// Returns a dictionary that represents the <code>AccidentInfo</code> object.
- (NSDictionary * _Nonnull)toDictionary SWIFT_WARN_UNUSED_RESULT;
/// Returns a JSON formatted string that represents the <code>AccidentInfo</code> object.
- (NSString * _Nonnull)toJson SWIFT_WARN_UNUSED_RESULT;
@end

enum FairmaticInsurancePeriod : NSInteger;

/// Information about the active drive if any.
SWIFT_CLASS_NAMED("ActiveDriveInfo")
@interface FairmaticActiveDriveInfo : NSObject
/// The unique Id for this drive
@property (nonatomic, readonly, copy) NSString * _Nonnull driveId;
/// The start timestamp of trip in milliseconds since epoch.
@property (nonatomic) int64_t startTimestamp;
/// The insurance period for this drive
@property (nonatomic) enum FairmaticInsurancePeriod insurancePeriod;
/// The current speed of vehicle in metres/second.
@property (nonatomic) double currentSpeed;
/// The distance covered so far in this trip in meters.
@property (nonatomic) double distance;
/// Tracking id is specified by the enclosing application when it
/// wants to start a drive manually by calling <code>Fairmatic.startManualDrive(_:completionHandler:)</code>
/// This may be the case for example in a taxi cab application that would
/// know when to start a drive based on when a meter gets flagged. trackingId will be
/// nil in case of auto detected drives.
@property (nonatomic, copy) NSString * _Nullable trackingId;
/// Session id is specified by the enclosing application when it wants to
/// record a session using <code>Fairmatic.startSession(_:)</code>
/// sessionId will be nil if there is no session associated with that drive.
@property (nonatomic, copy) NSString * _Nullable sessionId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum FairmaticDriveType : NSInteger;
enum FairmaticUserMode : NSInteger;
@class FairmaticEvent;
@class FairmaticDriveScore;
@class FairmaticEventRatings;
enum FairmaticPhonePosition : NSInteger;
@class FairmaticTripWarning;
@class FairmaticExtrapolationDetails;

/// Wrapper for meta-information related to a drive.
SWIFT_CLASS_NAMED("DriveInfo")
@interface FairmaticDriveInfo : NSObject
/// The unique Id for this drive
@property (nonatomic, copy) NSString * _Null_unspecified driveId;
/// The type of the drive. This decides what other info parameters will be populated.
/// A drive callback will be sent even for falsely detected drives or for non
/// automobile trips (Eg. biking, public transport).
@property (nonatomic) enum FairmaticDriveType driveType;
/// Whether the user was a driver or a passenger.
/// Driver/Passenger detection is disabled by default. Talk to your
/// contact in <code>Fairmatic</code> to enable this feature. Only present when <code>driveType</code> is
/// <code>DriveType.drive</code> and the SDK was able to determine with confidence
/// whether the user was a driver or a passenger.
/// If the SDK was not able to determine the user mode, this field is
/// <code>UserMode.unavailable</code>.
@property (nonatomic) enum FairmaticUserMode userMode;
/// The insurance period for this drive
@property (nonatomic) enum FairmaticInsurancePeriod insurancePeriod;
/// The start timestamp of trip in milliseconds since epoch.
@property (nonatomic) int64_t startTimestamp;
/// The end timestamp of trip in milliseconds since epoch
@property (nonatomic) int64_t endTimestamp;
/// The average speed of trip in metres/second
@property (nonatomic) double averageSpeed;
/// The maximum speed of trip in metres/second
/// If we do not receive any accurate location data during the drive, this
/// property would be set to -1
@property (nonatomic) double maxSpeed;
/// The distance of the trip in metres
@property (nonatomic) double distance;
/// A list of <code>LocationPoint</code> objects corresponding to this trip in
/// increasing order of timestamp. The first point corresponds to trip start location
/// and last to trip end location.
/// This is a sampled approximation of the drive which gives an indication of
/// the path taken by the driver. It is not the full detailed location data of the drive.
/// If no waypoints are recorded during the drive, this is an empty array.
@property (nonatomic, copy) NSArray<FairmaticLocationPoint *> * _Nonnull waypoints;
/// Tracking id is specified by the enclosing application when it
/// wants to start a drive manually by calling <code>Fairmatic.startManualDrive(_:completionHandler:)</code>
/// This may be the case for example in a taxi cab application that would
/// know when to start a drive based on when a meter gets flagged. trackingId will be
/// nil in case of auto detected drives.
@property (nonatomic, copy) NSString * _Nullable trackingId;
/// Session id is specified by the enclosing application when it wants to
/// record a session using <code>Fairmatic.startSession(_:)</code>
/// sessionId will be nil if there is no session associated with that drive.
@property (nonatomic, copy) NSString * _Nullable sessionId;
/// A list of <code>Event</code> objects for this trip in increasing order of timestamp.
/// In case of no events in the trip an empty list is returned.
@property (nonatomic, copy) NSArray<FairmaticEvent *> * _Nonnull events;
/// The driving behaviour score for this trip.
@property (nonatomic, strong) FairmaticDriveScore * _Nonnull score;
/// The ratings of individual events for this trip
@property (nonatomic, strong) FairmaticEventRatings * _Nonnull eventRatings;
/// The position of the phone during this trip.
@property (nonatomic) enum FairmaticPhonePosition phonePosition;
/// A list of <code>TripWarning</code> objects for this trip.
/// In case of no warnings in the trip an empty list is returned.
@property (nonatomic, copy) NSArray<FairmaticTripWarning *> * _Nonnull tripWarnings;
/// The type of vehicle.
/// If <code>driveType</code> is not <code>DriveType.drive</code> then it will be set to <code>VehicleType.unknown</code>.
/// NOTE: This value will only be populated in <code>FairmaticDelegate.processAnalysis(ofDrive:)</code> callback.
@property (nonatomic) enum FairmaticVehicleType vehicleType;
/// The extrapolated details for a drive.
/// If <code>driveType</code> is not <code>DriveType.drive</code> then it will be set to nil.
@property (nonatomic, strong) FairmaticExtrapolationDetails * _Nullable extrapolationDetails;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// This contains the fully analyzed results for a drive, this is returned from
/// <code>FairmaticDelegate.processAnalysis(ofDrive:)</code> callback for all the trips with the value of
/// <code>DriveInfo.driveType</code> not set to <code>DriveType.invalid</code>.
/// The data of this type will always be of equal or better quality than
/// <code>EstimatedDriveInfo</code> returned from <code>FairmaticDelegate.processEnd(ofDrive:)</code>
/// Typically <code>FairmaticDelegate.processAnalysis(ofDrive:)</code> will be fired within
/// a few seconds after <code>FairmaticDelegate.processEnd(ofDrive:)</code> callback but in some rare cases
/// this delay can be really large depending on phone network conditions.
/// The callback for this <code>FairmaticDelegate.processAnalysis(ofDrive:)</code> will be fired in trip
/// occurrence sequence, i.e. from oldest trip to the latest trip.
SWIFT_CLASS_NAMED("AnalyzedDriveInfo")
@interface FairmaticAnalyzedDriveInfo : FairmaticDriveInfo
@end


/// Wrapper to describe a bluetooth device.
SWIFT_CLASS_NAMED("BluetoothDevice")
@interface FairmaticBluetoothDevice : NSObject
/// The name of the bluetooth device.
@property (nonatomic, copy) NSString * _Nonnull name;
/// The mac address of the bluetooth device.
@property (nonatomic, copy) NSString * _Nonnull identifier;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Collision severity of the detected accident.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticCollisionSeverity, "CollisionSeverity", open) {
/// unknown severity collision.
  FairmaticCollisionSeverityUnknown = 0,
/// low severity collision
  FairmaticCollisionSeverityLow = 1,
/// high severity collision.
  FairmaticCollisionSeverityHigh = 2,
};

@class FairmaticDriverAttributes;
enum FairmaticDriveDetectionMode : NSInteger;
enum FairmaticRegion : NSInteger;

/// This class contains parameters required by <code>Fairmatic</code> during setup.
SWIFT_CLASS_NAMED("Configuration")
@interface FairmaticConfiguration : NSObject
/// Your SDK key.
/// Pass in the SDK key for your app.
/// This field is REQUIRED and should be a valid string.
/// Check <code>Fairmatic.isValidInputParameter(_:)</code> to validate this field. Nil strings are not
/// allowed.
/// Passing invalid string would cause SDK setup to fail.
@property (nonatomic, copy) NSString * _Nonnull sdkKey;
/// Unique ID for the current user. This can be any ID used by your app to
/// identify its users.
/// Use <code>Fairmatic.isValidInputParameter(_:)</code> to verify that userId is valid.
/// This field is REQUIRED and should be a valid string.
/// Passing invalid string would cause SDK setup to fail.
@property (nonatomic, copy) NSString * _Nonnull driverId;
/// Attributes for the current user. These attributes are stored on the server
/// and are provided in Fairmatic’s APIs. Any existing attributes would be overwritten
/// on the server when a non-nil value for this param is passed. Passing nil is a no-op.
/// Use this param to provide meta-information about the user like name,
/// email, groupId or any custom attributes you wish to provide.
/// Default value is nil.
@property (nonatomic, strong) FairmaticDriverAttributes * _Nullable driverAttributes;
/// Use this mode to control the SDK’s behaviour for detecting drives
/// automatically. This mode can be changed at a later point using
/// <code>Fairmatic.setDriveDetectionMode(_:completionHandler:)</code> method.
/// Applications which do not want the SDK to continuously track drives in
/// background should set this value to <code>DriveDetectionMode.autoOFF</code>. With this, the
/// application needs to call <code>Fairmatic.startManualDrive(_:completionHandler:)</code> method to record drives. In case the application
/// wants to enable auto drive detection only for a fixed duration (like when the driver is
/// on-duty), use method <code>Fairmatic.setDriveDetectionMode(_:completionHandler:)</code>
/// to change the mode to <code>DriveDetectionMode.autoON</code> for that period and set it
/// back to <code>DriveDetectionMode.autoOFF</code> (once the driver goes off-duty).
@property (nonatomic) enum FairmaticDriveDetectionMode driveDetectionMode;
/// This field is OPTIONAL.
/// Default value is <code>Region.us</code>.
/// Application will not be allowed to change the region post Fairmatic SDK setup.
/// To change region application should call <code>Fairmatic.wipeOut()</code> api first.
@property (nonatomic) enum FairmaticRegion region;
/// Developers have to set this property to <code>true</code> if the app implements multiple accident callbacks -
/// potential callback and final callback.
/// If set to <code>false</code>, the SDK assumes that potential accident callback is not implemented.
/// The default value of this property is <code>false</code>.
@property (nonatomic) BOOL implementsMultipleAccidentCallbacks;
/// Creates a Fairmatic <code>Configuration</code> object.
- (nonnull instancetype)initWithApplicationKey:(NSString * _Nonnull)applicationKey driverId:(NSString * _Nonnull)driverId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Direction of impact detected by SDK at the time of the accident
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticDirectionOfImpact, "DirectionOfImpact", open) {
/// Indicates an unknown direction of impact
  FairmaticDirectionOfImpactUnknown = 0,
/// Indicates a front direction of impact
  FairmaticDirectionOfImpactFront = 1,
/// Indicates a rear direction of impact
  FairmaticDirectionOfImpactRear = 2,
/// Indicates a broadside direction of impact
  FairmaticDirectionOfImpactBroadside = 3,
};


/// The category that best indicates the type of trip
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticDriveCategory, "DriveCategory", open) {
/// Indicates that the trip was taken in a car
  FairmaticDriveCategoryCar = 0,
/// Indicates that the trip was taken in a car and the user was the driver
  FairmaticDriveCategoryCarDriver = 1,
/// Indicates that the trip was taken in a car and the user was a passenger
  FairmaticDriveCategoryCarPassenger = 2,
/// Indicates that the trip was taken in a train or a subway
  FairmaticDriveCategoryTrain = 3,
/// Indicates that the trip was taken in a bus
  FairmaticDriveCategoryBus = 4,
/// Indicates that the trip was taken on a bicycle
  FairmaticDriveCategoryBicycle = 5,
/// Indicates that the trip was taken on a motorcycle
  FairmaticDriveCategoryMotorcycle = 6,
/// Indicates that the trip was taken on foot (either walking or running)
  FairmaticDriveCategoryFoot = 7,
/// Indicates that the trip was taken using some form of public transit
/// (bus/train/subway/tram etc)
  FairmaticDriveCategoryTransit = 8,
/// Indicates that the trip was taken using some form of air travel
  FairmaticDriveCategoryFlight = 9,
/// Indicates that there wasn’t enough movement and this shouldn’t have been
/// detected as a trip
  FairmaticDriveCategoryInvalid = 97,
/// Indicates that the trip was not taken in a car. This includes everything
/// other than <code>DriveCategory.car</code>
  FairmaticDriveCategoryNotCar = 98,
/// Fallback when the above options do not cover the use case.
/// This maybe used when the mode of transport is not covered above (eg. snow-mobile) or
/// when enough information is not available to put it in one of the above categories
  FairmaticDriveCategoryOther = 99,
};

/// Dictates the functioning of Fairmatic’s drive detection.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticDriveDetectionMode, "DriveDetectionMode", open) {
/// <code>Fairmatic</code> SDK will automatically track drives in background in
/// this mode once the SDK is setup. At the same time, the application can invoke
/// <code>+[Fairmatic startManualDrive:completionHandler]</code> to explicitly start recording a drive.
/// This is the Default mode.
  FairmaticDriveDetectionModeAutoON = 0,
/// In this mode auto drive-detection is disabled. All other APIs on <code>Fairmatic</code>
/// can be invoked independent of this mode. For recording trips in this mode, the
/// application has to explicitly invoke the <code>+[Fairmatic startManualDrive:completionHandler]</code> method.
  FairmaticDriveDetectionModeAutoOFF = 1,
/// In this mode drive detection is controlled by period APIs present in
/// <code>FairmaticInsurance</code> class. Only <code>FairmaticInsurance</code> APIs should be used in
/// this mode to control <code>FairmaticSDK</code> behavior.
  FairmaticDriveDetectionModeInsurance = 2,
};



/// Information about a drive that was resumed in the <code>Fairmatic</code> SDK.
/// This is called after the drive recording resumes after a gap. The gap may occur due to
/// an application restart by the OS, application kill and restart by a user, an application crash
/// etc.
SWIFT_CLASS_NAMED("DriveResumeInfo")
@interface FairmaticDriveResumeInfo : NSObject
/// The unique Id for this drive
@property (nonatomic, readonly, copy) NSString * _Nonnull driveId;
/// The insurance period for this drive
@property (nonatomic) enum FairmaticInsurancePeriod insurancePeriod;
/// The start timestamp of trip in milliseconds since epoch.
@property (nonatomic) int64_t startTimestamp;
/// The distance of the trip in metres
@property (nonatomic) double distance;
/// A list of <code>LocationPoint</code> objects corresponding to this trip in
/// increasing order of timestamp. The first point corresponds to trip start location
/// and last to trip end location.
/// This is a sampled approximation of the drive which gives an indication of
/// the path taken by the driver. It is not the full detailed location data of the drive.
/// If no waypoints are recorded during the drive, this is an empty array.
@property (nonatomic, copy) NSArray<FairmaticLocationPoint *> * _Nonnull waypoints;
/// Tracking id is specified by the enclosing application when it
/// wants to start a drive manually by calling <code>Fairmatic.startManualDrive(_:completionHandler:)</code>
/// This may be the case for example in a taxi cab application that would
/// know when to start a drive based on when a meter gets flagged. trackingId will be
/// nil in case of auto detected drives.
@property (nonatomic, copy) NSString * _Nullable trackingId;
/// Session id is specified by the enclosing application when it wants to
/// record a session using <code>Fairmatic.startSession(_:)</code>
/// sessionId will be nil if there is no session associated with that drive.
@property (nonatomic, copy) NSString * _Nullable sessionId;
/// The start timestamp of the gap in drive recording in milliseconds.
/// The drive was resumed after this gap.
@property (nonatomic) int64_t driveGapStartTimestampMillis;
/// The end timestamp of the gap in drive recording in milliseconds.
/// The drive was resumed after this gap.
@property (nonatomic) int64_t driveGapEndTimestampMillis;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Driving Behaviour scores for a drive.
/// The scores are expressed as a number between 0 to 100 and will be -1 if not available.
/// High scores indicate safe driving and low scores reflect hazardous or risky driving patterns.
/// Preventive or corrective actions should be prescribed in extreme cases.
SWIFT_CLASS_NAMED("DriveScore")
@interface FairmaticDriveScore : NSObject
/// The <code>Zendrive</code> score for this drive. The zendrive score measures the focus, control and
/// cautiousness of a driver. It reflects the accident risk associated with this drive.
/// The scores is expressed as a number between 0 to 100 and will be -1 if not available.
@property (nonatomic) NSInteger zendriveScore;
/// Default initializer for creating a <code>DriveScore</code> object.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Initializer for creating a <code>DriveScore</code> object.
/// \param zendriveScore The <code>Zendrive</code> score for this drive.
///
- (nonnull instancetype)initWithZendriveScore:(NSInteger)zendriveScore OBJC_DESIGNATED_INITIALIZER;
@end


/// Information about start of a drive.
SWIFT_CLASS_NAMED("DriveStartInfo")
@interface FairmaticDriveStartInfo : NSObject
/// The unique Id for this drive
@property (nonatomic, readonly, copy) NSString * _Nonnull driveId;
/// The start timestamp of trip in milliseconds since epoch
@property (nonatomic) int64_t startTimestamp;
/// The insurance period for this drive
@property (nonatomic) enum FairmaticInsurancePeriod insurancePeriod;
/// The distance of the trip in metres
@property (nonatomic) double distance;
/// A list of <code>LocationPoint</code> objects corresponding to this trip in
/// increasing order of timestamp. The first point corresponds to trip start location.
/// This array contains a series of <code>LocationPoint</code> which
/// approximate the path taken by the driver. This is not the detailed location
/// data but rather a sample representing route geometry.
/// note:
/// The array might be empty if no accurate gps location is determined till
/// <code>FairmaticDelegate.processStart(ofDrive:)</code> call.
@property (nonatomic, copy) NSArray<FairmaticLocationPoint *> * _Nullable waypoints;
/// Tracking id is specified by the enclosing application when it
/// wants to start a drive manually by calling <code>Fairmatic.startManualDrive(_:completionHandler:)</code>
/// This may be the case for example in a taxi cab application that would
/// know when to start a drive based on when a meter gets flagged. trackingId will be
/// nil in case of auto detected drives.
@property (nonatomic, copy) NSString * _Nullable trackingId;
/// Session id is specified by the enclosing application when it wants to
/// record a session using <code>Fairmatic.startSession(_:)</code>
/// sessionId will be nil if there is no session associated with that drive.
@property (nonatomic, copy) NSString * _Nullable sessionId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// The type of the drive returned from <code>DriveInfo.driveType</code>.
/// This decides what other <code>DriveInfo</code> parameters will be populated.
/// A drive callback can be sent as a false alarm or when we detect that the user was not
/// actually driving but moved using other means of transport.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticDriveType, "DriveType", open) {
/// Sometimes, the SDK detects that a trip is invalid after it has been started.
/// In these cases, the values for <code>DriveInfo.waypoints</code>, <code>DriveInfo.events</code>,
/// <code>DriveInfo.score</code>, <code>DriveInfo.maxSpeed</code> and <code>DriveInfo.averageSpeed</code>
/// will have invalid values.
  FairmaticDriveTypeInvalid = 0,
/// This was not a driving trip. For e.g bike and train rides will fall under this trip type.
/// The <code>DriveInfo</code> will have <code>DriveInfo.waypoints</code>, <code>DriveInfo.maxSpeed</code>,
/// <code>DriveInfo.averageSpeed</code>, <code>DriveInfo.events</code> and <code>DriveInfo.score</code>.
  FairmaticDriveTypeNonDriving = 1,
/// This trip was taken in a valid <code>FairmaticVehicleType</code>.
/// If the SDK determined the user to be a driver or a passenger, the value
/// will be available in <code>DriveInfo.userMode</code>
/// The <code>DriveInfo</code> will have <code>DriveInfo.waypoints</code>, <code>DriveInfo.maxSpeed</code>,
/// <code>DriveInfo.averageSpeed</code>, <code>DriveInfo.events</code> and <code>DriveInfo.score</code>.
  FairmaticDriveTypeDrive = 2,
};

enum FairmaticServiceLevel : NSInteger;

/// Additional attributes of a <code>Fairmatic</code> driver.
/// The application can specify both predefined and custom attributes for a driver.
/// These attributes are associated with a SDK driverId at SDK initialization time.
/// In addition to predefined special attributes, up to 4 custom key value attributes
/// can be associated with a driver using the Fairmatic SDK.
/// warning:
/// All attribute keys can be atmost 64 characters in length.
/// warning:
/// All attribute values can be atmost 1024 characters in length.
SWIFT_CLASS_NAMED("DriverAttributes")
@interface FairmaticDriverAttributes : NSObject
/// Set the email for the current driver
/// \param emailId The email to be set
///
- (void)setEmailId:(NSString * _Nonnull)emailId;
/// Set the phone number for the current driver
/// \param phoneNumber The phone number to be set
///
- (void)setPhoneNumber:(NSString * _Nonnull)phoneNumber;
/// A unique id that associates the current user to a group. This groupId will
/// be made available as a query parameter to filter users in the reports and API that
/// <code>Fairmatic</code> provides.
/// For example, ‘EastCoast’ and ‘WestCoast’ can be groupIds to distinguish
/// users from these regions. Another example would be using city names as groupIds. Check
/// <code>Fairmatic.isValidInputParameter(_:)</code> method to validate group id. Setting an invalid
/// groupId is a no-op and would log an error.
/// \param groupId A string representing the group of a user.
///
///
/// returns:
/// <code>true</code>, if the value was set, <code>false</code> otherwise.
- (BOOL)setGroup:(NSString * _Nonnull)groupId SWIFT_WARN_UNUSED_RESULT;
/// The service level of a driver. This is useful for applications where <code>Fairmatic</code> supports
/// different service levels for different drivers. See ServiceLevel
/// for more information about this attribute.
/// \param serviceLevel service tier of the user.
///
- (BOOL)setServiceLevel:(enum FairmaticServiceLevel)serviceLevel SWIFT_WARN_UNUSED_RESULT;
/// Set the custom attribute of the user.
/// Up to 4 custom attributes can be set for a user.
/// A new value for an existing key would be overwritten only if the value length
/// is within 1024 characters, otherwise the original value would be retained.
/// \param key A key for the custom attribute. The maximum key length is 64 characters.
///
/// \param value Value of the custom attribute. The maximum value length is 1024 characters.
///
///
/// returns:
/// <code>true</code>, if the value was set, <code>false</code> otherwise.
- (BOOL)setCustomAttribute:(NSString * _Nonnull)value forKey:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
/// Alias is a string placeholder offered as a convenience
/// for developers to create a reference for a driver
/// \param alias alias for the user.
///
///
/// returns:
/// <code>true</code>, if the value was set, <code>false</code> otherwise.
- (BOOL)setAlias:(NSString * _Nonnull)alias SWIFT_WARN_UNUSED_RESULT;
/// Set the vehicle type for the driver.
/// To enable the feature for any vehicle type other than <code>VehicleType.car</code>,
/// please reach out to your contact at Fairmatic
/// \param vehicleType The <code>VehicleType</code> for the driver.
/// Passing <code>VehicleType.unknown</code> is a no-op.
///
///
/// returns:
/// <code>true</code>, if the value was set, <code>false</code> otherwise.
- (BOOL)setVehicleType:(enum FairmaticVehicleType)vehicleType SWIFT_WARN_UNUSED_RESULT;
/// Returns driver attributes as a json string. Empty string if json serialization
/// fails.
- (NSString * _Nonnull)asJson SWIFT_WARN_UNUSED_RESULT;
/// Returns the driver attributes as a dictionary.
- (NSDictionary * _Nonnull)asDictionary SWIFT_WARN_UNUSED_RESULT;
/// Creates a <code>DriverAttributes</code> object.
- (nonnull instancetype)init;
@end


/// Keys for various properties returned by toJson method.
SWIFT_CLASS_NAMED("DriverAttributesKeys")
@interface FairmaticDriverAttributesKeys : NSObject
/// Key for groupId returned by toJson method.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull driverAttributesKeyGroup;)
+ (NSString * _Nonnull)driverAttributesKeyGroup SWIFT_WARN_UNUSED_RESULT;
/// Key for ServiceLevel returned by toJson method.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull driverAttributesKeyPriority;)
+ (NSString * _Nonnull)driverAttributesKeyPriority SWIFT_WARN_UNUSED_RESULT;
/// Key for driver alias returned by toJson method.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull driverAttributesKeyAlias;)
+ (NSString * _Nonnull)driverAttributesKeyAlias SWIFT_WARN_UNUSED_RESULT;
/// Key for driver email returned by toJson method
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull driverAttributesKeyEmail;)
+ (NSString * _Nonnull)driverAttributesKeyEmail SWIFT_WARN_UNUSED_RESULT;
/// Key for driver phone returned by toJson method
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull driverAttributesKeyPhone;)
+ (NSString * _Nonnull)driverAttributesKeyPhone SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// This contains the best estimated results for a drive, this is returned from
/// <code>FairmaticDelegate.processEnd(ofDrive estimatedDriveInfo:)</code> callback.
/// The data of this type will always be of same or little bad quality than
/// <code>AnalyzedDriveInfo</code> returned from <code>FairmaticDelegate.processAnalysis(ofDrive analyzedDriveInfo:)</code>
/// All drives with driveType not set to <code>DriveType.invalid</code> will get a
/// corresponding <code>FairmaticDelegate.processAnalysis(ofDrive analyzedDriveInfo:)</code> callback.
/// Typically <code>FairmaticDelegate.processAnalysis(ofDrive analyzedDriveInfo:)</code> will be fired within
/// a few seconds after <code>FairmaticDelegate.processEnd(ofDrive estimatedDriveInfo:)</code> callback but in some rare cases
/// this delay can be really large depending on phone network conditions.
SWIFT_CLASS_NAMED("EstimatedDriveInfo")
@interface FairmaticEstimatedDriveInfo : FairmaticDriveInfo
@end

enum FairmaticventType : NSInteger;
enum FairmaticEventSeverity : NSInteger;
enum FairmaticTurnDirection : NSInteger;
@class FairmaticSpeedingData;

/// Represents a driving behavior event like phone use, aggressive acceleration etc.
/// It is part of <code>DriveInfo</code> object of <code>Fairmatic.processEnd(ofDrive estimatedDriveInfo:)</code> callback.
SWIFT_CLASS_NAMED("Event")
@interface FairmaticEvent : NSObject
/// Start location of the event.
@property (nonatomic, strong) FairmaticLocationPoint * _Nonnull startLocation;
/// Stop location of the event.
@property (nonatomic, strong) FairmaticLocationPoint * _Nonnull stopLocation;
/// Epoch timestamp of the start of the event.
@property (nonatomic) int64_t startTime;
/// Epoch timestamp of the end of the event;
@property (nonatomic) int64_t endTime;
/// The type of the event.
@property (nonatomic) enum FairmaticventType eventType;
/// The severity of the event.
@property (nonatomic) enum FairmaticEventSeverity eventSeverity;
/// Denotes the turn direction of a hard turn whether a left or right turn.
@property (nonatomic) enum FairmaticTurnDirection turnDirection;
/// Additional data in the <code>eventType</code> is <code>Event.overSpeeding</code>, will be nil otherwise.
@property (nonatomic, strong) FairmaticSpeedingData * _Nullable speedingData;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Represents ratings associated with the various event types for a trip. Higher rating for an event
/// represents safe driving behaviour with respect to that event. For cases where rating is absent,
/// <code>StarRating.NA</code> is reported.
/// seealso:
/// <code>StarRating</code>
SWIFT_CLASS_NAMED("EventRatings")
@interface FairmaticEventRatings : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// This is returned in <code>Event.eventSeverity</code>, it represents the
/// severity of event if application for that event type.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticEventSeverity, "EventSeverity", open) {
/// Severity not applicable for this event type.
  FairmaticEventSeverityNone = 0,
/// This is a low severity event.
  FairmaticEventSeverityLow = 1,
/// This is a high severity event.
  FairmaticEventSeverityHigh = 2,
};

/// The event type as specified in <code>Event.eventType</code>
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticventType, "EventType", open) {
/// This denotes the aggressive behavior of braking too hard.
  FairmaticventTypeHardBrake = 0,
/// This denotes the aggressive behavior of accelerating too fast.
  FairmaticventTypeAggressiveAcceleration = 1,
/// This denotes the distracting behavior of handling the phone while driving.
  FairmaticventTypePhoneHandling = 2,
/// This denotes the aggressive behavior of speeding more than allowed.
/// You will also receive <code>Event.speedingData</code> in this case.
  FairmaticventTypeOverSpeeding = 3,
/// This denotes a collision as detected by Fairmatic SDK.
/// You will also receive <code>FairmaticDelegate.processAccidentDetected(_:)</code>
/// in realtime for this event.
  FairmaticventTypeAccident = 4,
/// This denotes a hard turn as detected by Fairmatic SDK.
  FairmaticventTypeHardTurn = 5,
/// This denotes the distracting behavior of interacting with the phone screen while driving.
  FairmaticventTypePhoneScreenInteraction = 6,
/// This denotes stop sign violations as detected by Fairmatic SDK.
  FairmaticventTypeStopSignViolation = 7,
/// This denotes the distracting behavior of being in a phone call, hands free.
  FairmaticventTypeHandsFreePhoneCall = 8,
/// This denotes the phone screen is on but user is not actively interacting with the screen.
  FairmaticventTypePassiveDistraction = 9,
};


/// Wrapper for extrapolated details for a drive.
SWIFT_CLASS_NAMED("ExtrapolationDetails")
@interface FairmaticExtrapolationDetails : NSObject
/// The additional distance that might be covered before the drive start is detected.
@property (nonatomic) double extrapolatedDistance;
/// The estimated start location of the active drive.
@property (nonatomic, strong) FairmaticLocationPoint * _Nonnull estimatedStartLocation;
/// Initializer for <code>ExtrapolationDetails</code>.
- (nonnull instancetype)init;
@end

@protocol FairmaticDelegate;
@class FairmaticState;
@class FairmaticSettings;
@class NSNumber;
@class FairmaticShiftDetail;
@class NSError;
enum FairmaticSDKHealthReason : NSInteger;

/// Fairmatic Object.
SWIFT_CLASS_NAMED("Fairmatic")
@interface Fairmatic : NSObject
/// No initialization needed from the client
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Initializes the Fairmatic SDK to automatically detect driving and collect
/// data. Client code should call this method before anything else in the Fairmatic API.
/// This method requires network connection to validate the applicationKey from the server.
/// Setup fails and returns NO if network is not available.
/// This method returns <code>false</code> whenever setup fails and sets up the error with the
/// error code, cause and description.
/// Things to Consider:-
/// <ul>
///   <li>
///     To change the <code>Configuration.region</code>, you need to call <code>+wipeOut:</code> first.
///   </li>
///   <li>
///     If you are doing multiple setups, i.e calling this API multiple times and the newer setup fails,
///     then the SDK may continue working according to parameters provided in older setup or
///     it may get torndown. In all such cases please check <code>isSDKSetup</code> in the completion
///     handler to confirm if SDK is setup or not.
///   </li>
///   <li>
///     If <code>Configuration.driverId</code> or <code>Configuration.applicationKey</code> is changed while
///     doing multiple setups, it will be the same as calling teardown followed by calling setup with the
///     new parameters.
///   </li>
/// </ul>
/// When data collection needs to be stopped call the teardown method.
/// This might be done for example when the application’s user has
/// logged out (and possibly a different user might login later).
/// \param configuration The configuration object used to setup the SDK. This
/// object contains your credentials along with
/// additional setup parameters that you can use to provide
/// meta-information about the user or to tune the sdk
/// functionality.
///
/// \param delegate The delegate object on which Fairmatic SDK will issue callbacks for
/// handling various events. Can be <code>nil</code> if you do not want to
/// register for callbacks.
/// The delegate can also be set at a later point using <code>setDelegate(_:)</code>
/// method.
///
/// \param handler This block is called when fairmatic setup completes.
/// The application is expected to use the success and error
/// params passed to this block to handle failures. The handler
/// would be invoked on the main thread. Can be nil.
///
+ (void)setupWith:(FairmaticConfiguration * _Nonnull)configuration delegate:(id <FairmaticDelegate> _Nullable)delegate completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))handler;
/// Set delegate to receive callbacks for various events from Fairmatic SDK.
/// See <code>FairmaticDelegate</code> for further details.
/// Calling this if Fairmatic is not setup is a no-op.
/// seealso:
/// <code>setup(with:delegate:completionHandler:)</code> for further details.
/// \param delegate The delegate object to give callbacks on.
///
+ (void)setDelegate:(id <FairmaticDelegate> _Nullable)delegate;
/// The drive detection mode controls how Fairmatic SDK detects drives.
/// See <code>DriveDetectionMode</code> for further details.
/// Use this method to get the current <code>DriveDetectionMode</code>.
+ (enum FairmaticDriveDetectionMode)getDriveDetectionMode SWIFT_WARN_UNUSED_RESULT;
/// Change the drive detection mode to control how Fairmatic SDK detects drives.
/// See <code>DriveDetectionMode</code> for further details. This will override the mode sent
/// with <code>Configuration</code> during setup.
/// Calling this method stops an ongoing auto-detected drive.
/// If the SDK is not setup calling this method will result in a no-op.
/// \param driveDetectionMode The new drive detection mode.
///
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// success, A boolean that suggests if drive is started successfully
/// error, A valid error <code>FairmaticError</code> object with <code>fairmaticErrorDomain</code> is
/// returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError.notSetup</code>
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)setDriveDetectionMode:(enum FairmaticDriveDetectionMode)driveDetectionMode completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Stops driving data collection. The application can disable the Fairmatic SDK
/// by invoking this method. This method is asynchronous.
/// The teardown method is internally synchronized with
/// <code>setup(with:delegate:completionHandler:)</code> method, and the enclosing
/// application should avoid synchronizing the two methods independently. Calling this
/// with nil completion handler is same as calling teardown method.
/// \param handler Called when method completes. The handler would be invoked on main
/// thread. Can be nil.
///
+ (void)teardownWithCompletionHandler:(void (^ _Nullable)(void))handler;
/// Wipe out all the data that Fairmatic keeps locally on the device.
/// When Fairmatic SDK is torn down, trip data that is locally persisted continues to remain persisted.
/// The data will be uploaded when SDK setup is called at a later time.
/// Wipeout should be used when the application wants to remove all traces of Fairmatic on the device.
/// Data cannot be recovered after this call.
/// NOTE: This call can only be made when the SDK is not running.
/// Call <code>teardown(completionHandler:)</code> to tear down a live SDK before making this call.
+ (void)wipeOutWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// This API allows application to override Fairmatic’s auto drive detection
/// algorithm.
/// Invoking this method forces the start of a drive. If this API is
/// used then it is application’s responsibility to terminate the drive by
/// invoking <code>stopManualDrive(_:)</code> method. If an auto-detected drive is in progress, that drive
/// is stopped and a new drive is started.
/// These methods should be used only by applications which have explicit
/// knowledge of start and end of drives and want to attribute drive data to
/// specific trackingIds.
/// Calling it without having initialized the Fairmatic framework
/// <code>setup(with:delegate:completionHandler:)</code> is a no-op.
/// Calling <code>startManualDrive(_:completionHandler:)</code> with the same trackingId without calling <code>stopManualDrive(_:)</code> in between
/// is a no-op. Calling <code>startManualDrive(_:completionHandler:)</code> with a different trackingId: with implicitly call
/// stopManualDrive(_:) before starting a new drive.
/// This is an asynchronous method, <code>FairmaticeDelegate.processStart(ofDrive:)</code>
/// is triggered once this finishes with basic information about the drive
/// <code>activeDriveInfo</code> will return nil until <code>FairmaticDelegate.processStart(ofDrive:)</code> is called
/// seealso:
/// <code>stopManualDrive(_:)</code>
/// You need to call <code>stopManualDrive(_:)</code> to stop drive data collection.
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// isSuccess, A boolean that suggests if drive is started successfully
/// error, A valid error of <code>fairmaticErrorDomain</code> is
/// returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError.notSetup</code>, <code>FairmaticError.invalidTrackingId</code>
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)startManualDrive:(NSString * _Nullable)trackingId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// This should be called to indicate the end of a drive started by invoking
/// <code>startManualDrive(_:completionHandler:)</code>
/// This block has no return value and two arguments:
/// the error, A valid error of <code>fairmaticErrorDomain</code> is
/// returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError.notSetup</code>, <code>FairmaticError.invalidTrackingId</code>,
/// <code>FairmaticError.internalFailure</code>. Refer to <code>FairmaticError</code> for more details on the errors.
/// success, A boolean that suggests if drive is stopped successfully
/// Calling it without having initialized the Fairmatic SDK is a no-op.
/// seealso:
/// <code>startManualDrive(_:completionHandler:)</code>
+ (void)stopManualDrive:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Start a session in the SDK.
/// Applications which want to record several user’s drives as a session may use
/// this call.
/// All drives, either automatically detected or started using <code>startManualDrive(_:completionHandler:)</code>,
/// will be tagged with the sessionId if a session is already in progress. If a drive
/// is already on when this call is made, that drive will not belong to this
/// session.
/// This session id will be made available as a query parameter in the
/// reports and API that Fairmatic provides.
/// The application must call <code>stopSession()</code> when it wants to end the session.
/// Only one session may be active at a time. Calling startSession when a session is
/// already active with a new sessionId will stop the ongoing session and start a new
/// one.
/// Calling it without having initialized the Fairmatic SDK is a no-op.
/// \param sessionId an identifier that identifies this session uniquely. Cannot
/// be null or an empty string. Cannot be longer than 64 characters.
/// Use <code>isValidInputParameter(_:)</code> to verify that groupId is valid.
/// Passing invalid string is a no-op.
///
+ (void)startSession:(NSString * _Nonnull)sessionId;
/// Stop currently ongoing session. No-op if no session is ongoing. Trips that
/// start after this call do not belong to the session. Ongoing trips at the time of this
/// call will continue to belong to the session that was just stopped.
/// seealso:
/// <code>startSession(_:)</code>
+ (void)stopSession;
/// Use this method to check whether the parameter string passed
/// to the SDK is valid.
/// All strings passed as input params to Fairmatic SDK cannot contain
/// the following characters-
/// “?”, “ “, “&”, “/”, “", “;”, “#”
/// Non-ascii characters are not allowed.
/// \param input The string to validate.
///
///
/// returns:
/// <code>true</code> if the string is <code>nil</code> or valid, <code>false</code> otherwise.
+ (BOOL)isValidInputParameter:(NSString * _Nullable)input SWIFT_WARN_UNUSED_RESULT;
/// Returns <code>true</code> if the Fairmatic SDK is already setup. Else <code>false</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL isSDKSetup;)
+ (BOOL)isSDKSetup SWIFT_WARN_UNUSED_RESULT;
/// Returns an identifier which can be used to identify this SDK build.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull buildVersion;)
+ (NSString * _Nonnull)buildVersion SWIFT_WARN_UNUSED_RESULT;
/// Get info on the currently active drive. If sdk is not setup or if
/// no drive is in progress, nil is returned.
///
/// returns:
/// The currently active drive information.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) FairmaticActiveDriveInfo * _Nullable activeDriveInfo;)
+ (FairmaticActiveDriveInfo * _Nullable)activeDriveInfo SWIFT_WARN_UNUSED_RESULT;
/// Get the current state of the Fairmatic SDK.
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and a single argument:
/// state, A Fairmatic <code>State</code> object that informs about the current state
/// of the sdk. If the SDK is not set up, the state is nil.
///
+ (void)getState:(void (^ _Nullable)(FairmaticState * _Nullable))completionHandler;
/// Returns a boolean indicating whether Fairmatic SDK can detect accidents
/// on this devices or not.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL isAccidentDetectionSupportedByDevice;)
+ (BOOL)isAccidentDetectionSupportedByDevice SWIFT_WARN_UNUSED_RESULT;
/// Returns a NSDictionary with keys as <code>EventType</code> and values being Bool which represent
/// if a particular event will be detected by the SDK on this device.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NSDictionary * _Nonnull getEventSupportForDevice;)
+ (NSDictionary * _Nonnull)getEventSupportForDevice SWIFT_WARN_UNUSED_RESULT;
/// Send a debug report of the current driver to Fairmatic.
/// The Fairmatic SDK will create a background task to ensure the
/// completion of this upload task.
+ (void)uploadAllDebugDataAndLogs;
///
/// returns:
/// A valid <code>Settings</code> object if the SDK is setup, otherwise nil.
+ (FairmaticSettings * _Nullable)getSettings SWIFT_WARN_UNUSED_RESULT;
/// After success of pauseAutoTracking request, automatic trip detection by the SDK will be paused till pausedTillTimestamp which will be provided as part of the parameter.
/// Refer to <code>FairmaticError</code> to get details on the errors returned by the completion handler of this method.
/// Example:
/// \code
/// let pausedTillTimestamp = 1634014320000;
/// try Fairmatic.pauseAutoTracking(pausedTillTimestamp);
///
/// \endcode\param pausedTillTimestamp - till the pausedTillTimestamp auto tracking will be paused 
///
+ (void)pauseAutoTracking:(int64_t)pausedTillTimestamp completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// After success of resumeAutoTracking request, auto tracking of the SDK will be resumed right away.
/// Refer to <code>FairmaticError</code> to get details on the errors returned by the completion handler of this method.
/// Example:
/// \code
/// try Fairmatic.resumeAutoTracking;
///
/// \endcode
+ (BOOL)resumeAutoTrackingAndReturnError:(NSError * _Nullable * _Nullable)error completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// After success of isAutoTrackingPaused request, it will return the current status of SDK’s auto tracking.
/// The return bool is wrapped in a NSNumber for objective-c compatibility.
/// Refer to <code>FairmaticError</code> to get details on the errors thrown by this method.
/// Example:
/// \code
/// try Fairmatic.isAutoTrackingPaused().boolValue;
///
/// \endcode
+ (NSNumber * _Nullable)isAutoTrackingPausedAndReturnError:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Instantly Refreshes the business hours, the SDK makes an API call to the backend to fetch the latest business hours.
/// <ul>
///   <li>
///     <code>completionHandler:</code> A block object to be executed when the task finishes.
///     this block has no return value and 2 arguments
///     shiftDetails, A nullable <code>FairmaticShiftDetail</code> object which provides the business hours.
///     error.
///     possible error codes returned:
///   </li>
/// </ul>
/// \code
///  FairmaticError.notSetup,
///  FairmaticError.refreshBusinessHoursTimeout,
///  FairmaticError.refreshBusinessHoursNetworkNotAvailable,
///  FairmaticError.refreshBusinessHoursFeatureNotEnabled
///
/// \endcodeExample:
/// \code
/// Fairmatic.refreshBusinessHours { (shiftDetail, error) in
///     if let error = error {
///         // handle error
///     } else {
///        // Handle business hours
///     }
/// }
///
/// \endcode
+ (void)refreshBusinessHoursWithCompletionHandler:(void (^ _Nonnull)(FairmaticShiftDetail * _Nullable, NSError * _Nullable))completionHandler;
/// Logs all the critical permissions required by the SDK
/// \param sdkHealthReason indicates the reason for logging SDK Health
///
+ (void)logSDKHealth:(enum FairmaticSDKHealthReason)reason completionHandler:(void (^ _Nonnull)(NSError * _Nullable))completionHandler;
@end

typedef SWIFT_ENUM(NSInteger, FairmaticDayOfWeek, open) {
  FairmaticDayOfWeekSunday = 1,
  FairmaticDayOfWeekMonday = 2,
  FairmaticDayOfWeekTuesday = 3,
  FairmaticDayOfWeekWednesday = 4,
  FairmaticDayOfWeekThursday = 5,
  FairmaticDayOfWeekFriday = 6,
  FairmaticDayOfWeekSaturday = 7,
};


/// Delegate for <code>Fairmatic</code>.
SWIFT_PROTOCOL_NAMED("FairmaticDelegate")
@protocol FairmaticDelegate <NSObject>
@optional
/// Called on delegate in the main thread when <code>Fairmatic</code> SDK detects a potential
/// start of a drive.
/// \param startInfo Info about drive start. Refer to <code>DriveStartInfo</code> for
/// further details.
///
- (void)processStartOfDrive:(FairmaticDriveStartInfo * _Nonnull)startInfo;
/// Called on delegate in the main thread when <code>Fairmatic</code> SDK resumes a
/// drive after a gap.
/// The gap in drive recording may occur due to an application restart by the OS,
/// application kill and restart by a user, an application crash or other reasons.
/// Drives started by calling <code>Fairmatic.startManualDrive(_:completionHandler:)</code> are always resumed and they
/// will not end until <code>Fairmatic.stopManualDrive(_:)</code> is called.
/// \param resumeInfo Info about drive resume. Refer to <code>DriveResumeInfo</code> for
/// further details.
///
- (void)processResumeOfDrive:(FairmaticDriveResumeInfo * _Nonnull)resumeInfo;
/// Called on the delegate in the main thread when <code>Fairmatic</code> SDK detects a drive
/// to have been completed.
/// It is possible that <code>Fairmatic</code> SDK might decide at a later time that an
/// ongoing trip was a falsely detected trip. In such scenario <code>processEnd(ofDrive:)</code> will be
/// invoked on delegate with <code>DriveInfo</code>.driveType set to <code>DriveType.invalid</code>.
/// Every trip with <code>DriveInfo</code>.driveType not set to <code>DriveType.invalid</code>
/// will receive a corresponding <code>processAnalysis(ofDrive:)</code> callback containing
/// additional info related to this drive.
/// \param estimatedDriveInfo Best estimate info about the drive.
/// Refer to <code>EstimatedDriveInfo</code> for further details.
///
- (void)processEndOfDrive:(FairmaticEstimatedDriveInfo * _Nonnull)estimatedDriveInfo;
/// Called on the delegate in the main thread when <code>Fairmatic</code> SDK finishes
/// full analysis of all valid drives returned from <code>processEnd(ofDrive:)</code> callback.
/// This will be called for all the <code>processEnd(ofDrive:)</code> callbacks
/// with the value of <code>DriveInfo</code>.driveType not set to <code>DriveType.invalid</code>.
/// This may contain additional or improved data over the <code>EstimatedDriveInfo</code>
/// returned from <code>processEnd(ofDrive:)</code>
/// Typically this callback will be fired within a few seconds after <code>processEnd(ofDrive:)</code>
/// callback but in some rare cases this delay can be really large depending on
/// phone network conditions.
/// This callback will be fired in trip occurrence sequence, i.e from oldest trip to
/// the latest trip.
/// \param analyzedDriveInfo Analyzed insights of the drive.
///
- (void)processAnalysisOfDrive:(FairmaticAnalyzedDriveInfo * _Nonnull)analyzedDriveInfo;
/// [Disabled by default]
/// This callback is fired on the main thread when a potential accident is detected by the SDK during a drive.
/// This is a preliminary callback of a potential collision. This collision is confirmed or invalidated by
/// <code>processAccidentDetected(_:)</code> callback.
/// To enable, reach out to your contact at Fairmatic
/// \param accidentInfo Info about accident.
///
- (void)processPotentialAccidentDetected:(FairmaticAccidentInfo * _Nonnull)accidentInfo;
/// This callback is fired on the main thread when an accident is detected by
/// the SDK during a drive. Any ongoing auto-detected/manual drives will be stopped
/// after this point.
/// \param accidentInfo Info about accident.
///
- (void)processAccidentDetected:(FairmaticAccidentInfo * _Nonnull)accidentInfo;
/// This callback gives information about errors in device or application settings that
/// may be affecting Fairmatic SDK.
/// This callback is fired on the main thread after SDK setup and whenever
/// location permission or <code>Configuration.driveDetectionMode</code> changes,
/// provided the location permission is determined.
/// The recommended flow is to ask for the permissions before SDK is setup
/// because if the location permission is not determined this callback will not be
/// fired.
/// If you receive this callback in the foreground you can show the errors using  any UI
/// constructs like alert controllers, if this callback is received in the background you can
/// use a notification. If you want to add actions to the notification then please don’t
/// rely on errors received at the time of notification as they might have changed by
/// the time the user clicks on the notification. Instead use <code>Fairmatic.getSettings()</code>
/// to get the latest errors and show appropriate message to the user.
/// \param settings A valid <code>Settings</code> object that contains
/// information about errors affecting the Fairmatic SDK.
///
- (void)settingsChanged:(FairmaticSettings * _Nonnull)settings;
/// This callback is fired when the SDK detects a change in the business hours set by the fleet manager and the current
/// business hours applied on the SDK.
/// NOTE: To fetch the businessHours instantly use <code>Fairmatic.refreshBusinessHours(_:)</code>
/// \param businessHours, a valid ‘ShiftDetail’ object that contains  the new business hours that are applied by the 
/// fleet manager.
///
- (void)businessHoursChanged:(FairmaticShiftDetail * _Nonnull)businessHours;
@end

/// Error returned as code to NSError from <code>Fairmatic</code> public APIs in case of
/// failures.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticError, "FairmaticError", open) {
/// SDK Key used in setup is invalid
  FairmaticErrorInvalidSDKKeyString = 0,
/// Network not reachable, Fairmatic.setup sometimes needs network call
/// for authentication and to update SDK configuration to work. This error
/// is returned whenever network is not available in these scenarios.
  FairmaticErrorNetworkUnreachable = 1,
/// Fairmatic SDK does not support the OS version of the device.
  FairmaticErrorUnsupportedOSVersion = 2,
/// Fairmatic SDK does not support the device type.
  FairmaticErrorDeviceUnsupported = 3,
/// Invalid parameter was passed to the API.
  FairmaticErrorInvalidParams = 101,
/// Internal error.
  FairmaticErrorInternalFailure = 102,
/// Fairmatic SDK is not setup. This error is also returned in case SDK setup
/// has started but completion handler for setup is not called yet.
  FairmaticErrorNotSetup = 103,
/// Insurance Period hasn’t changed from the previously active period, action ignored.
/// This error may be returned from <code>FairmaticInsurance.startDrive(withPeriod1:)</code>, <code>FairmaticInsurance.startDrive(withPeriod2:completionHandler:)</code>,
/// <code>FairmaticInsurance.startDrive(withPeriod3:completionHandler:)</code>.
  FairmaticErrorInsurancePeriodSame = 104,
/// Invalid <code>trackingId</code> passed for new drive. This error may be returned from
/// <code>FairmaticInsurance.startDrive(withPeriod2:completionHandler:)</code>,
/// <code>FairmaticInsurance.startDrive(withPeriod3:completionHandler:)</code>.
  FairmaticErrorInvalidTrackingId = 105,
/// Fairmatic SDK is not torn down. This error is returned if the requested operation cannot
/// be completed while the SDK is running like the wipeout API.
  FairmaticErrorNotTornDown = 106,
/// Some IO error occured while doing the operation. Refer to error description for more info.
  FairmaticErrorIoError = 107,
/// Operation failed because <code>Region</code> provided was invalid.
  FairmaticErrorInvalidRegion = 108,
/// Operation Failed because provided <code>Region</code> is not supported for this application.
  FairmaticErrorRegionUnsupported = 109,
/// Changing region post setup is NOT allowed, until <code>Fairmatic.wipeOut()</code> is called.
  FairmaticErrorUnauthorizedRegionSwitch = 110,
/// User is not authorized to use this application.
  FairmaticErrorUserDeprovisioned = 111,
/// Operation failed because the set vehicle type feature is disabled in the config.
  FairmaticErrorUnsupportedVehicleType = 112,
/// Failed to register beacon due to invalid UUID string.
  FairmaticErrorInvalidBeaconUUID = 113,
/// Failed to remove beacon as beacon was not found.
  FairmaticErrorBeaconNotFound = 114,
/// maximum number of beacons registered for a given user has been reached.
  FairmaticErrorMaxBeaconLimitReached = 115,
/// pausedTillTimestamp parameter passed to the <code>Fairmatic.pauseAutoTracking(_:)</code> API must be in future
  FairmaticErrorExpiredPausedTillTimestamp = 116,
/// this error is thrown when <code>Fairmatic.refreshBusinessHours(_:)</code> is timed out.
  FairmaticErrorRefreshBusinessHoursTimeout = 117,
/// this error is thrown in case of network unavailability when <code>Fairmatic.refreshBusinessHours(_:) </code> is called.
  FairmaticErrorRefreshBusinessHoursNetworkNotAvailable = 118,
/// this error is thrown when <code>Fairmatic.refreshBusinessHours(_:)</code> is called but business hours feature is not enabled.
  FairmaticErrorRefreshBusinessHoursFeatureNotEnabled = 119,
/// This error is thrown when the Fairmatic SDK is not enabled for the current customer. Please get in touch with your contact at Fairmatic to get it enabled and then retry the setup API.
  FairmaticErrorSdkNotEnabled = 1000,
};
static NSString * _Nonnull const FairmaticErrorDomain = @"FairmaticSDK.FairmaticError";


/// Class for providing feedback back to <code>Fairmatic</code>
SWIFT_CLASS_NAMED("FairmaticFeedback")
@interface FairmaticFeedback : NSObject
/// Help <code>Fairmatic</code> improve by providing feedback for a drive detected by the SDK.
/// \param driveId As returned at the end of drive in <code>DriveInfo</code>.
///
/// \param driveCategory The category that best indicates the type of Drive.
///
+ (void)addDriveCategoryWithDriveId:(NSString * _Nonnull)driveId driveCategory:(enum FairmaticDriveCategory)driveCategory;
/// Help <code>Fairmatic</code> improve by providing information about whether an
/// event detected by the SDK occurred or not.
/// \param driveId As returned at the end of drive in <code>DriveInfo</code> which
/// this event is part of
///
/// \param eventTimestamp As returned in <code>Event.startTime</code>
///
/// \param eventType As returned in <code>Event.eventType</code>
///
/// \param occurrence Whether the event occurred or not
///
+ (void)addEventOccurrenceWithDriveId:(NSString * _Nonnull)driveId eventTimestamp:(int64_t)eventTimestamp eventType:(enum FairmaticventType)eventType occurrence:(BOOL)occurrence;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Applications which want to record Fairmatic insurance periods for a driver may use these APIs.
/// All drives (automatically detected or manually started) when a period is in progress
/// will be tagged with the period id. This period id will be made available in the reports and API
/// that Fairmatic provides
/// Only one period can be active at a time.
/// Switching periods or calling <code>FairmaticInsurance.stopPeriod(_:)</code> stops any active drives (automatic or manual).
/// A drive with multiple insurance periods will be split into multiple trips for different
/// insurance periods.
SWIFT_CLASS_NAMED("FairmaticInsurance")
@interface FairmaticInsurance : NSObject
/// Start Fairmatic insurance period 1 in the SDK.
/// A manual trip of id trackingId will be started immediately on this call.
/// The entire duration in this period will be recorded as a single trip.
/// If period 1 is already in progress with the same trackingId, this call will be a no-op.
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// isSuccess, A boolean that suggests successful completion of the call
/// the error, A valid error of <code>fairmaticErrorDomain</code> is
/// returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError.notSetup</code>, <code>FairmaticError.insurancePeriodSame</code>,
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)startDriveWithPeriod1:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Start Fairmatic insurance period 2 in the SDK.
/// A manual trip of id trackingId will be started immediately on this call.
/// The entire duration in this period will be recorded as a single trip.
/// If period 2 is already in progress with the same trackingId, this call will be a no-op.
/// \param trackingId An identifier which allows identifying this drive uniquely.
/// This drive identifier must be unique for the user.
///
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// isSuccess, A boolean that suggests successful completion of the call
/// the error, A valid error of <code>fairmaticErrorDomain</code> is
/// returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError.notSetup</code>, <code>FairmaticError.insurancePeriodSame</code>,
/// <code>FairmaticError.invalidTrackingId</code>. Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)startDriveWithPeriod2:(NSString * _Nonnull)trackingId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Start Fairmatic insurance period 3 in the SDK.
/// A manual trip of id trackingId will be started immediately on this call.
/// The entire duration in this period will be recorded as a single trip.
/// If period 3 is already in progress with the same trackingId, this call will be a no-op.
/// \param trackingId An identifier which allows identifying this drive uniquely.
/// This drive identifier must be unique for the user.
///
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// isSuccess, A boolean that suggests successful completion of the call
/// the error, A valid error of <code>fairmaticErrorDomain</code> is
/// returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError.notSetup</code>, <code>FairmaticError.insurancePeriodSame</code>,
/// <code>FairmaticError.invalidTrackingId</code>. Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)startDriveWithPeriod3:(NSString * _Nonnull)trackingId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Stop currently ongoing Fairmatic insurance period if any.
/// Ongoing trips at the time of this call will be stopped.
/// Auto trip detection is turned off on this call.
/// \param completionHandler A block object to be executed when the task finishes.
/// This block has no return value and two arguments:
/// isSuccess, A boolean that suggests successful completion of the call
/// the error, A valid error of <code>fairmaticErrorDomain</code> is
/// returned in case of a failure.
/// Possible error codes returned: <code>FairmaticError.notSetup</code>.
/// Refer to <code>FairmaticError</code> for more details on the errors.
///
+ (void)stopPeriod:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, FairmaticPauseReason, open) {
  FairmaticPauseReasonUser = 0,
  FairmaticPauseReasonBusinessHours = 1,
  FairmaticPauseReasonNotPaused = 2,
};

@class FairmaticMockAccidentConfig;

/// This class contains methods that mock Fairmatic’s functionality for testing purposes.
SWIFT_CLASS_NAMED("FairmaticTest")
@interface FairmaticTest : NSObject
/// Use this method to test <code>Fairmatic</code> Accident detection integration. Works only in
/// DEBUG mode, disabled in RELEASE mode.
/// On invoking this method, you will get an accident callback finalId on your
/// delegate after 5 seconds. You can look at console logs for debugging in case you
/// do not receive the callback. If issue persists, reach out to your contact at Fairmatic.
/// warning:
/// While invoking this method on a simulator, make sure your are simulating
/// location (In Simulator menu bar, select Features->Location->Apple).
/// \param confidence Any value from <code>AccidentConfidence</code> enum.
///
+ (void)raiseMockAccident:(enum FairmaticAccidentConfidence)confidence;
/// Use this method to test <code>Fairmatic</code> Accident detection integration. Works only in DEBUG mode,
/// disabled in RELEASE mode.
/// This API can be used to test multiple callbacks. You need to enable <code>Configuration.implementsMultipleAccidentCallbacks</code>
/// for that.
/// In case of multiple callbacks enabled, on invoking this method, you will get a potential accident callback
/// on your delegate. After <code>MockAccidentConfig.delayBetweenCallbacks</code>seconds, you will
/// get a final accident callback.
/// In case only single callback is enabled by setting <code>FairmaticConfiguration.implementsMultipleAccidentCallbacks</code> as <code>false</code>,
/// on invoking this method, you will get a final accident callback callback.
/// You can look at console logs for debugging in case you do not receive the callback.
/// If issue persists, reach out to your contact at Fairmatic.
/// warning:
/// While invoking this method on a simulator, make sure your are simulating
/// location (In Simulator menu bar, select Features->Location->Apple).
/// \param config Configuration which determines the <code>AccidentInfo</code> values in the two callbacks.
///
+ (void)raiseMockAccidentUsing:(FairmaticMockAccidentConfig * _Nonnull)config;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class FairmaticVehicleInfo;
@class FairmaticScannedBeaconInfo;

/// This class manages association and dissociation of vehicles to Fairmatic SDK.
SWIFT_CLASS_NAMED("FairmaticVehicleTagging")
@interface FairmaticVehicleTagging : NSObject
/// Associates the vehicle to Fairmatic SDK.
/// After successful association of vehicle information, whenever Fairmatic SDK will detect
/// a connection to this bluetooth device while the user is driving, it will include this vehicleId
/// in the tags array of <code>AnalyzedDriveInfo</code>.
/// If the user connect to bluetooth of multiple associated vehicles during the drive
/// the latest vehicleId will be used as tag.  Maximum of two vehicles can be associated.
/// note:
/// The bluetooth device of the associated vehicle needs to be the audio route for some
/// duration of the drive for tagging to happen.
/// Refer to <code>FairmaticVehicleTaggingError</code> to get details on the errors thrown by this method.
/// Example:
/// \code
/// let vehicleInfo = VehicleInfo(vehicleId: "vehicleId",
///                               bluetoothId: "14:0F:C7:62:F8:9E")
/// try FairmaticVehicleTagging.associateVehicle(vehicleInfo)
///
/// \endcodeBluetooth stereos in automobiles are primarily classic Bluetooth devices, which might not be discoverable from your app.
/// When you associate the user’s vehicle, ask the user to connect their stereo and play audio.
/// Then, use <code>getActiveBluetoothDevice()</code> to determine the active bluetooth connection and get the identifier
/// of the device.
/// Start with this code:
/// \code
///  if let bluetoothDevice = FairmaticVehicleTagging.getActiveBluetoothDevice() {
///     let vehicleInfo = VehicleInfo(vehicleId: "vehicleId",
///                                   bluetoothId: bluetoothDevice.identifier)
///     try FairmaticVehicleTagging.associateVehicle(vehicleInfo)
///  }
///
/// \endcode\param vehicleInfo The <code>VehicleInfo</code> object to associate.
///
+ (BOOL)associateVehicle:(FairmaticVehicleInfo * _Nonnull)vehicleInfo error:(NSError * _Nullable * _Nullable)error;
/// Dissociates the vehicle from Fairmatic SDK.
/// After successful dissociation of the vehicle, Fairmatic SDK will stop tagging the trips for this vehicle.
/// Refer to <code>FairmaticVehicleTaggingError</code> to get details on the errors thrown by this method.
/// Example:
/// \code
/// let vehicleInfo = VehicleInfo(vehicleId: "vehicleId",
///                               bluetoothId: "14:0F:C7:62:F8:9E")
/// try FairmaticVehicleTagging.dissociateVehicle(vehicleInfo.vehicleId)
///
/// \endcode\param vehicleId The vehicleId of the vehicle which is to be dissociated.
///
+ (BOOL)dissociateVehicle:(NSString * _Nonnull)vehicleId error:(NSError * _Nullable * _Nullable)error;
///
/// returns:
/// - The list of associated vehicles if sdk is setup, else nil.
+ (NSArray<FairmaticVehicleInfo *> * _Nullable)getAssociatedVehicles SWIFT_WARN_UNUSED_RESULT;
/// Returns the active bluetooth device, if there is any, otherwise returns nil.
/// The active bluetooth device is the one through which audio will play.
/// Example: You may be connected to both car’s stereo and airpods but only
/// one of them will be active, the one through which audio is playing or
/// will play.
/// note:
/// If the user does not have multiple connected audio devices
/// like headphones, airpods etc, then the connected car’s stereo is the
/// active device.
+ (FairmaticBluetoothDevice * _Nullable)getActiveBluetoothDevice SWIFT_WARN_UNUSED_RESULT;
/// Get all the beacons which are in the device’s range.
/// Example:
/// \code
/// FairmaticVehicleTagging.getNearbyBeacons(uuid: "FD94C06F-8667-46C2-A334-14C6BF8EDEC3",
///  major: 100,
///  minor: 100,
///  completionHandler: { (beaconsList: [FairmaticScannedBeaconInfo], error:  NSError?) -> Void in
///      if let error = error {
///          // handle the error
///      }
///     // update scanned beacons list in state or redraw UI
///     })
///
/// \endcode\param uuid The UUID of the beacons that are to be scanned.
///
/// \param major The major of the beacons that are to be scanned.
///
/// \param minor The minor of the beacons that are to be scanned.
///
/// \param completionHandler The completion handler which is to be executed after the completion of beacon scan.
///
+ (void)getNearbyBeaconsWithUuid:(NSString * _Nonnull)uuid major:(int32_t)major minor:(int32_t)minor completionHandler:(void (^ _Nonnull)(NSArray<FairmaticScannedBeaconInfo *> * _Nonnull, NSError * _Nullable))completionHandler;
/// Get all the beacons which are in the device’s range.
/// Example:
/// \code
/// FairmaticVehicleTagging.getNearbyBeacons(uuid: "FD94C06F-8667-46C2-A334-14C6BF8EDEC3",
///  completionHandler: { (beaconsList: [FairmaticScannedBeaconInfo], error:  NSError?) -> Void in
///      if let error = error {
///          // handle the error
///      }
///     // update scanned beacons list in state or redraw UI
///     })
///
/// \endcode\param uuid The UUID of the beacons that are to be scanned.
///
/// \param completionHandler The completion handler which is to be executed after the completion of beacon scan.
///
+ (void)getNearbyBeaconsWithUuid:(NSString * _Nonnull)uuid completionHandler:(void (^ _Nonnull)(NSArray<FairmaticScannedBeaconInfo *> * _Nonnull, NSError * _Nullable))completionHandler;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// Error returned as code to NSError from <code>FairmaticVehicleTagging</code> public APIs
/// in case of failures.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticVehicleTaggingError, "FairmaticVehicleTaggingError", open) {
/// Fairmatic SDK is not setup. This error is also returned in case SDK setup
/// has started but completion handler for setup is not called yet.
  FairmaticVehicleTaggingErrorNotSetup = 0,
/// <code>VehicleInfo</code> object passed to <code>FairmaticVehicleTagging.associateVehicle(_:)</code>
/// is invalid because of one of the following reasons:-
/// <ol>
///   <li>
///     It is nil.
///   </li>
///   <li>
///     <code>VehicleInfo.vehicleId</code> is nil or has more than 64 characters.
///   </li>
///   <li>
///     <code>VehicleInfo.vehicleId</code> doesn’t satisfy <code>Fairmatic.isValidInputParameter(_:)</code>.
///   </li>
///   <li>
///     <code>VehicleInfo.bluetoothId</code> is not a valid mac address.
///   </li>
/// </ol>
  FairmaticVehicleTaggingErrorInvalidVehicleInfo = 1,
/// <code>FairmaticVehicleTagging.associateVehicle(_:)</code> called for vehicle whose vehicleId
/// or bluetoothId or both conflicts with an already associated vehicle.
  FairmaticVehicleTaggingErrorAssociatedVehicleConflict = 2,
/// <code>FairmaticVehicleTagging.associateVehicle(_:)</code> called for more than two vehicles.
  FairmaticVehicleTaggingErrorAssociatedVehiclesLimitExceeded = 3,
/// vehicleId passed to <code>FairmaticVehicleTagging.dissociateVehicle(_:)</code>
/// is invalid because of one of the following reasons:-
/// <ol>
///   <li>
///     It is nil.
///   </li>
///   <li>
///     It has more than 64 characters.
///   </li>
///   <li>
///     It doesn’t satisfy <code>+[Fairmatic isValidInputParameter:]</code>.
///   </li>
/// </ol>
  FairmaticVehicleTaggingErrorInvalidVehicleId = 4,
/// <code>FairmaticVehicleTagging.dissociateVehicle(_:)</code> called for an unassociated vehicle.
  FairmaticVehicleTaggingErrorVehicleNotAssociated = 5,
/// <code>FairmaticVehicleTagging.getNearbyBeacons(uuid:major:minor:completionHandler:)</code> failed to scan for beacons.
  FairmaticVehicleTaggingErrorBeaconScanTimeout = 6,
};
static NSString * _Nonnull const FairmaticVehicleTaggingErrorDomain = @"FairmaticSDK.FairmaticVehicleTaggingError";

/// The types of insurance period in <code>Fairmatic</code>
/// Each drive belongs to exactly one of these insurance periods.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticInsurancePeriod, "InsurancePeriod", open) {
/// Applications that do not use insurance APIs will have drives with
/// this value for insurance period
  FairmaticInsurancePeriodNoPeriod = 0,
/// Drives detected in insurance period 1 will have this value.
/// Refer: <code>FairmaticInsurance.startDrive(withPeriod1:)</code>
  FairmaticInsurancePeriodPeriod1 = 1,
/// Drives undertaken with insurance period 2 will have this value.
/// Refer: <code>FairmaticInsurance.startDrive(withPeriod2:completionHandler:)</code>
  FairmaticInsurancePeriodPeriod2 = 2,
/// Drives undertaken with insurance period 3 will have this value.
/// Refer: <code>FairmaticInsurance.startDrive(withPeriod3:completionHandler:)</code>
  FairmaticInsurancePeriodPeriod3 = 3,
};


/// Represents a geographical coordinate.
SWIFT_CLASS_NAMED("LocationPoint")
@interface FairmaticLocationPoint : NSObject
/// Epoch timestamp of the location point.
@property (nonatomic, readonly) int64_t timestamp;
/// Latitude in degrees
@property (nonatomic, readonly) double latitude;
/// Longitude in degrees
@property (nonatomic, readonly) double longitude;
/// Initializer for LocationPoint
/// \param timestamp Epoch timestamp of the location
///
/// \param latitude Latitude in degrees
///
/// \param longitude Longitude in degrees
///
///
/// returns:
/// LocationPoint object
- (nonnull instancetype)initWithTimestamp:(int64_t)timestamp latitude:(double)latitude longitude:(double)longitude OBJC_DESIGNATED_INITIALIZER;
/// Compares any object with LocationPoint.
/// \param object an object to be compared with this LocationPoint object.
///
///
/// returns:
/// <code>true</code> if the given object is equal to this LocationPoint object,
/// <code>false</code> otherwise.
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// Returns a dictionary that represents the <code>LocationPoint</code> object.
- (NSDictionary * _Null_unspecified)toDictionary SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// This class contains parameters required by <code>FairmaticTest.raiseMockAccidentUsingConfig(using:)</code> for testing accident flow.
SWIFT_CLASS_NAMED("MockAccidentConfig")
@interface FairmaticMockAccidentConfig : NSObject <NSCopying>
/// This field specifies the confidence for the [potential accident callback][potentialId].
/// Default value is <code>AccidentConfidence.high</code>.
@property (nonatomic) enum FairmaticAccidentConfidence potentialAccidentConfidence;
/// This field specifies the confidence for the final accident callback.
/// Default value is <code>AccidentConfidence.high</code>.
@property (nonatomic) enum FairmaticAccidentConfidence finalAccidentConfidence;
/// This field specifies the confidence for the potential accident callback.
/// Default value is 70.
@property (nonatomic) NSInteger potentialAccidentConfidenceNumber;
/// This field specifies the confidence number for the final accident callback.
/// Default value is 70.
@property (nonatomic) NSInteger finalAccidentConfidenceNumber;
/// This field specifies the callback delay (in seconds) between the potential and final accident callback.
/// Default value is 20 seconds.
@property (nonatomic) NSInteger delayBetweenCallbacks;
/// This field specifies the vehicle type at the time of potential accident callback and final accident callback.
/// Default value is <code>VehicleType.car</code>.
@property (nonatomic) enum FairmaticVehicleType vehicleType;
/// This field specifies the collision severity at the time of potential accident callback and final accident callback.
/// Default value is <code>CollisionSeverity.high</code>.
@property (nonatomic) enum FairmaticCollisionSeverity collisionSeverity;
/// This field specifies the direction of impact at the time of potential accident callback and final accident callback.
/// Default value is <code>DirectionOfImpact.unknown</code>.
@property (nonatomic) enum FairmaticDirectionOfImpact directionOfImpact;
/// Creates a Fairmatic <code>MockAccidentConfig</code> object.
- (nonnull instancetype)init;
/// Creates a copy of Fairmatic <code>MockAccidentConfig</code> object.
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
/// This method causes the final callback to invalidate the potential callback.
/// Invalidating final callbacks have confidence number as 0 and confidence as <code>AccidentConfidence.invalid</code>,
/// signifying that the accident send out via the potential accident callback on further analysis has been reclassified as <em>not</em> being an accident.
- (void)invalidateFinalCallback;
@end







SWIFT_CLASS_NAMED("PausedReason")
@interface FairmaticPausedReason : NSObject
@property (nonatomic) enum FairmaticPauseReason pausedReason;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// The types of phone positions during a trip.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticPhonePosition, "PhonePosition", open) {
/// The case when <code>Fairmatic</code> was unable to determine the position of the phone during a trip.
  FairmaticPhonePositionUnknown = 0,
/// The case when <code>Fairmatic</code> was able to determine confidently that the phone was on mount during a trip.
  FairmaticPhonePositionMount = 1,
};

/// Dictates the region where user’s data will reside.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticRegion, "Region", open) {
/// Indicates that the user’s data will reside in US region.
/// This is the default region.
  FairmaticRegionUs = 0,
/// Indicates that the user’s data will reside in EU region.
  FairmaticRegionEu = 1,
};

/// Dictates the reason for is logging SDK Health
/// The SDK health will be recorded when there is any update in permission from last recorded SDK health.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticSDKHealthReason, "SDKHealthReason", open) {
/// Indicates the reason  is unknown.
/// This is the default value.
  FairmaticSDKHealthReasonUnknown = 0,
/// Indicates the SDK health will recorded due to silent push notification
  FairmaticSDKHealthReasonSilentPushNotification = 1,
/// Indicates the SDK health will recorded due to background processing
  FairmaticSDKHealthReasonBackgroundProcessing = 2,
};

@class CLBeacon;

/// Wrapper for beacons scanned using <code>FairmaticVehicleTagging.getNearbyBeacons(uuid:major:minor:completionHandler:)</code>.
SWIFT_CLASS_NAMED("ScannedBeaconInfo")
@interface FairmaticScannedBeaconInfo : NSObject
/// The UUID of the scanned beacon.
@property (nonatomic, copy) NSString * _Nonnull uuid;
/// The major of the scanned beacon.
@property (nonatomic) NSInteger major;
/// The minor of the scanned beacon.
@property (nonatomic) NSInteger minor;
/// The RSSI of the scanned beacon.
@property (nonatomic) NSInteger rssi;
/// Constants that reflect the relative distance to a beacon.
@property (nonatomic) CLProximity proximity;
/// The accuracy of the proximity value, measured in meters from the beacon.
@property (nonatomic) CLLocationAccuracy accuracy;
/// The timestamp representing when the beacon was observed.
@property (nonatomic) int64_t timestamp;
/// Initialize with UUID, major, minor, RSSI, proximity, accuracy.
- (nonnull instancetype)initWithUuid:(NSString * _Nonnull)uuid major:(NSInteger)major minor:(NSInteger)minor rssi:(NSInteger)rssi proximity:(CLProximity)proximity accuracy:(CLLocationAccuracy)accuracy timestamp:(int64_t)timestamp;
/// Initialize the beacon with UUID, major, minor.
- (nonnull instancetype)initWithUuid:(NSString * _Nonnull)uuid major:(int32_t)major minor:(int32_t)minor;
/// Initialize the beacon with a CLBeacon object.
- (nonnull instancetype)initWithClBeacon:(CLBeacon * _Nonnull)clBeacon;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Enumeration for different service levels supported by <code>Fairmatic</code> for a driver.
/// By default, drivers will be assigned to the default service level - ServiceLevel.default.
/// This is useful for applications which need special modes in the Fairmatic SDK for different
/// drivers - e.g default mode for free users and a advanced mode for paid users.
/// By default, multiple service levels are not enabled for an application.
/// To be able to use different modes for your application, you should reach out to your Fairmatic contact
/// with your requirements and get that enabled for your application.
/// Otherwise, if this is not enabled for your application, all drivers get mapped to
/// ServiceLevel.default irrespective of the service level specified.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticServiceLevel, "ServiceLevel", open) {
/// Default service level. This is most common level required by most of the applications
/// that use <code>Fairmatic</code> SDK.
  FairmaticServiceLevelLevelDefault = 0,
/// Special service level 1 that is enabled for a particular application.
/// Reach out to your Fairmatic contact with your requirements to get this enabled for your application.
  FairmaticServiceLevelLevel1 = 1,
};

@class FairmaticSettingsError;

/// This class surfaces errors in device or application settings that affects trip detection in the SDK.
SWIFT_CLASS_NAMED("Settings")
@interface FairmaticSettings : NSObject
/// List of errors that must be resolved for trip detection to work correctly.
@property (nonatomic, copy) NSArray<FairmaticSettingsError *> * _Nonnull errors;
/// Initializer for Settings
- (nonnull instancetype)initWithErrors:(NSArray<FairmaticSettingsError *> * _Nonnull)errors OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum FairmaticSettingsErrorType : NSInteger;

/// This class represent an error in device or application settings that is affecting
/// the ability of the SDK to detect trips.
SWIFT_CLASS_NAMED("SettingsError")
@interface FairmaticSettingsError : NSObject
/// Error type for SettingsError
@property (nonatomic) enum FairmaticSettingsErrorType errorType;
/// Initializer for SettingsError
- (nonnull instancetype)initWithErrorType:(enum FairmaticSettingsErrorType)errorType OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Error type for SettingError
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticSettingsErrorType, "SettingsErrorType", open) {
/// The location authorization status is determined but the user hasn’t granted
/// the <em>Always</em> location authorization to the application.
  FairmaticSettingsErrorTypeLocationPermissionNotAuthorized = 0,
/// The activity authorization status is determined but the user has <em>not authorized</em> application to
/// access the motion and fitness data. This error will only be thrown if activity based trip detection
/// is enabled for the application.
/// note:
/// if the current drive detection is <em>not</em> <code>DriveDetectionMode.autoON</code>, this
/// error will not be thrown.
  FairmaticSettingsErrorTypeActivityPermissionNotAuthorized = 1,
/// The location authorization is <em>Always</em> but location accuracy authorization
/// is <em>not</em> <code>CLAccuracyAuthorizationFullAccuracy</code>.
  FairmaticSettingsErrorTypeLocationAccuracyAuthorizationReduced = 2,
/// The location service is turned off.
  FairmaticSettingsErrorTypeLocationServiceOff = 3,
};

@class NSTimeZone;
@class FairmaticShiftInterval;

/// Represents a shift comprising of shift intervals over the week.
SWIFT_CLASS_NAMED("ShiftDetail")
@interface FairmaticShiftDetail : NSObject
/// The name of the shift.
@property (nonatomic, copy) NSString * _Nullable shiftName;
/// The unique identifer used to identify a shift.
@property (nonatomic, copy) NSString * _Nonnull shiftId;
/// A Timezone object which specifies the timezone of the shift.
@property (nonatomic, copy) NSTimeZone * _Nonnull timezone;
/// Shift intervals specify the intervals when the SDK should be active.
@property (nonatomic, copy) NSArray<FairmaticShiftInterval *> * _Nonnull shiftIntervals;
/// Initialize the shift details object with shiftName, shiftId, timezone and shiftIntervals.
- (nonnull instancetype)initWithShiftName:(NSString * _Nullable)shiftName shiftId:(NSString * _Nonnull)shiftId timezone:(NSTimeZone * _Nonnull)timezone shiftIntervals:(NSArray<FairmaticShiftInterval *> * _Nonnull)shiftIntervals OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class FairmaticShiftTime;

/// Wrapper for a single business hour interval.
SWIFT_CLASS_NAMED("ShiftInterval")
@interface FairmaticShiftInterval : NSObject
/// Start time of the shift interval, indicates when the shift interval starts.
@property (nonatomic, strong) FairmaticShiftTime * _Nonnull startTime;
/// End time of the shift interval, indicates when the shift interval ends.
@property (nonatomic, strong) FairmaticShiftTime * _Nonnull endTime;
/// Initialize the shift interval object with start time and end time.
- (nonnull instancetype)initWithStartTime:(FairmaticShiftTime * _Nonnull)startTime endTime:(FairmaticShiftTime * _Nonnull)endTime OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Represents a particular day and time in a weekly schedule, The shift time is represented in 24 hour time format.
SWIFT_CLASS_NAMED("ShiftTime")
@interface FairmaticShiftTime : NSObject
/// Represents the day of the week, range: [1-7]
@property (nonatomic) enum FairmaticDayOfWeek dayOfWeek;
/// Represents the hour of the day. range: [0-23].
@property (nonatomic) NSInteger hour;
/// Represents the minute of the hour. range: [0-59].
@property (nonatomic) NSInteger minute;
/// initializes the <code>ShiftTime</code> object.
/// Example
/// \code
/// let shiftTime = ShiftTime(dayOfWeek: .sunday, hour: 11, minute: 40)
///
/// \endcode
- (nonnull instancetype)initWithDayOfWeek:(enum FairmaticDayOfWeek)dayOfWeek hour:(NSInteger)hour minute:(NSInteger)minute;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A valid object of this class is returned in <code>Event.speedingData</code>
/// whenever <code>Event.eventType</code> is equal to <code>EventType.overSpeeding</code>.
SWIFT_CLASS_NAMED("SpeedingData")
@interface FairmaticSpeedingData : NSObject
/// The speed limit in metres per second.
@property (nonatomic) double speedLimitMPS;
/// The average speed of the user during this speeding event duration in metres per second.
@property (nonatomic) double userSpeedMPS;
/// Maximum speed of the user during this speeding event duration in metres per second.
@property (nonatomic) double maxUserSpeedMPS;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Fairmatic follows the star rating system, under which five star defined as the best rating with
/// one being the worst.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticStarRating, "StarRating", open) {
/// Indicates worst rating.
  FairmaticStarRatingOne = 1,
/// Indicates bad rating.
  FairmaticStarRatingTwo = 2,
/// Indicates an average rating.
  FairmaticStarRatingThree = 3,
/// Indicates good rating.
  FairmaticStarRatingFour = 4,
/// Indicates best rating.
  FairmaticStarRatingFive = 5,
/// Reported when rating is absent.
  FairmaticStarRatingNA = -1,
};


/// Represents the current state of the Fairmatic SDK.
SWIFT_CLASS_NAMED("State")
@interface FairmaticState : NSObject
/// The current configuration of the SDK.
/// Refer to <code>Configuration</code> for further details.
@property (nonatomic, strong) FairmaticConfiguration * _Null_unspecified fairmaticConfiguration;
/// Is the SDK currently tracking a drive?
@property (nonatomic) BOOL isDriveInProgress;
/// Current value of businessHour.
/// businessHour is set when the SDK detects a change in the business hours set by the fleet manager and the current
/// business hours applied on the SDK.
@property (nonatomic, strong) FairmaticShiftDetail * _Nullable shiftDetails;
/// Current value of pausedTillTimestamp.
/// pausedTillTimestamp is set when <code>Fairmatic.pauseAutoTracking(_:)</code> gets called.
@property (nonatomic) int64_t pausedTillTimestamp;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum FairmaticTripWarningType : NSInteger;

/// Represents a single warning that might have occurred during your trip.
/// A collection of these warnings are provided using the
/// <code>FairmaticDelegate.processAnalysis(ofDrive:)</code> callback.
SWIFT_CLASS_NAMED("TripWarning")
@interface FairmaticTripWarning : NSObject
/// The type of the trip warning.
@property (nonatomic, readonly) enum FairmaticTripWarningType tripWarningType;
/// Initializer for creating a <code>TripWarning</code>.
/// \param tripWarningType type of warning detected for the current drive.
///
- (nonnull instancetype)initWithWarning:(enum FairmaticTripWarningType)tripWarningType OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// The value return from <code>TripWarning.warning</code>.
/// Enum representing warnings detected for the current drive.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticTripWarningType, "TripWarningType", open) {
/// The trip duration is unexpectedly large and signifies a possible integration issue.
  FairmaticTripWarningTypeUnexpectedTripDuration = 0,
};

/// This is returned in <code>Event.turnDirection</code>, it represents the turn direction for <code>EventType.hardTurn</code>
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticTurnDirection, "TurnDirection", open) {
/// This is returned for all <code>Event.eventType</code> values other than <code>EventType.hardTurn</code>
  FairmaticTurnDirectionNotAvailable = 0,
/// Indicates that the turn direction of the event was Left.
  FairmaticTurnDirectionLeft = 1,
/// Indicates that the turn direction of the event was right.
  FairmaticTurnDirectionRight = 2,
};

/// The value return from <code>DriveInfo.userMode</code>. Indicates whether user
/// was a driver or passenger.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticUserMode, "UserMode", open) {
/// Indicates that the user was in the driver seat.
/// All values in <code>DriveInfo</code> will be set.
  FairmaticUserModeDriver = 0,
/// Indicates that the user was in the passenger seat.
/// <code>DriveInfo.score</code> will have default value. All other values will be set.
  FairmaticUserModePassenger = 1,
/// Indicates that either <code>DriveInfo.driveType</code> is not
/// <code>DriveType.drive</code> or <code>Fairmatic</code> was not able to determine user mode.
/// All values in <code>DriveInfo</code> will be set.
  FairmaticUserModeUnavailable = 2,
};


/// Wrapper for meta-information related to a vehicle.
SWIFT_CLASS_NAMED("VehicleInfo")
@interface FairmaticVehicleInfo : NSObject
/// The unique identifier for the vehicle.
/// This should not be nil, should not have more than 64 characters
/// and should satisfy <code>Fairmatic.isValidInputParameter(_:)</code>.
@property (nonatomic, copy) NSString * _Nonnull vehicleId;
/// The mac address of vehicles’s bluetooth device.
@property (nonatomic, copy) NSString * _Nonnull bluetoothId;
/// Initializer for <code>VehicleInfo</code>.
- (nonnull instancetype)init;
/// Initializer for <code>VehicleInfo</code>.
/// \param vehicleId The identifier for the vehicle.
///
/// \param bluetoothId The mac address of vehicle’s bluetooth device.
///
- (nonnull instancetype)initWithVehicleId:(NSString * _Nonnull)vehicleId bluetoothId:(NSString * _Nonnull)bluetoothId;
@end


/// Wrapper for vehicle tagging details for a drive.
SWIFT_CLASS_NAMED("VehicleTaggingDetails")
@interface FairmaticVehicleTaggingDetails : NSObject
/// The vehicleId of the tagged vehicle
@property (nonatomic, copy) NSString * _Nonnull vehicleId;
/// This flag determines if vehicle is tagged using beacon
@property (nonatomic) BOOL isTaggedByBeacon;
/// This flag determines if vehicle is tagged using bluetooth stereo
@property (nonatomic) BOOL isTaggedByBluetoothStereo;
/// Initializer for <code>VehicleTaggingDetails</code>.
- (nonnull instancetype)init;
@end

/// Type of vehicle used in the drive recorded by the Fairmatic SDK.
/// A default vehicle type can be set using <code>DriverAttributes.setVehicleType(_:)</code>
/// in <code>DriverAttributes</code>.
/// The detected type is returned to the application in the <code>AnalyzedDriveInfo.vehicleType</code>
/// field of the <code>FairmaticDelegate.processAnalysis(ofDrive:)</code> callback.
typedef SWIFT_ENUM_NAMED(NSInteger, FairmaticVehicleType, "VehicleType", open) {
/// Indicates a car vehicle type.
  FairmaticVehicleTypeCar = 0,
/// Indicates a motorcycle vehicle type.
  FairmaticVehicleTypeMotorcycle = 1,
/// Indicates that the user was not driving.
  FairmaticVehicleTypeUnknown = -1,
};

#endif
#if defined(__cplusplus)
#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
